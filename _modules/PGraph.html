

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PGraph &mdash; Simple graph functionality for Python  documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/graphviz.css?v=4ae1632d" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=5929fcd5"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            Simple graph functionality for Python
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../directed.html">Directed graphs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../undirected.html">Undirected graphs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../edge.html">Edge</a></li>
<li class="toctree-l1"><a class="reference internal" href="../planning.html">Path planning</a></li>
<li class="toctree-l1"><a class="reference internal" href="../matrices.html">Convert graph to matrix form</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Simple graph functionality for Python</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Module code</a></li>
      <li class="breadcrumb-item active">PGraph</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for PGraph</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span><span class="w"> </span><span class="nn">abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">ABC</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">copy</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Iterable</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">tempfile</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">subprocess</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">webbrowser</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">spatialmath.base.graphics</span><span class="w"> </span><span class="kn">import</span> <span class="n">axes_logic</span>


<div class="viewcode-block" id="PGraph">
<a class="viewcode-back" href="../planning.html#PGraph.PGraph">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">PGraph</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">heuristic</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># we use a list and a dict, the list respects the order of adding</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vertexlist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vertexdict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edgelist</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ncomponents</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_connectivitychange</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">metric</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metric</span> <span class="o">=</span> <span class="s2">&quot;L2&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metric</span> <span class="o">=</span> <span class="n">metric</span>
        <span class="k">if</span> <span class="n">heuristic</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">heuristic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metric</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">heuristic</span> <span class="o">=</span> <span class="n">heuristic</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;vertex&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">==</span><span class="mi">1</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;vertices&#39;</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ne</span><span class="si">}</span><span class="s2"> edge</span><span class="si">{</span><span class="s1">&#39;s&#39;</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">ne</span><span class="o">^</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nc</span><span class="si">}</span><span class="s2"> component</span><span class="si">{</span><span class="s1">&#39;s&#39;</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">nc</span><span class="o">^</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="n">s</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<div class="viewcode-block" id="PGraph.Dict">
<a class="viewcode-back" href="../PGraph.html#PGraph.PGraph.Dict">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">Dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create graph from parent/child dictionary</span>

<span class="sd">        :param d: dictionary that maps from ``Vertex`` subclass to ``Vertex`` subclass</span>
<span class="sd">        :type d: dict</span>
<span class="sd">        :param reverse: reverse link direction, defaults to False</span>
<span class="sd">        :type reverse: bool, optional</span>
<span class="sd">        :return: graph</span>
<span class="sd">        :rtype: UGraph or DGraph</span>

<span class="sd">        Behaves like a constructor for a ``DGraph`` or ``UGraph`` from a</span>
<span class="sd">        dictionary that maps vertices to parents.  From this information it</span>
<span class="sd">        can create a tree graph.</span>

<span class="sd">        By default parent vertices are linked their children. If ``reverse`` is</span>
<span class="sd">        True then children are linked to their parents.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">g</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">vertex</span><span class="p">,</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vertex</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">vertex_name</span> <span class="o">=</span> <span class="n">vertex</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">vertex_name</span> <span class="o">=</span> <span class="n">vertex</span><span class="o">.</span><span class="n">name</span>

            <span class="k">if</span> <span class="n">vertex_name</span> <span class="ow">in</span> <span class="n">g</span><span class="p">:</span>
                <span class="n">vertex</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="n">vertex_name</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">vertex</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="n">UVertex</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="n">vertex_name</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">parent_name</span> <span class="o">=</span> <span class="n">parent</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">parent_name</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="n">name</span>
            <span class="k">if</span> <span class="n">parent_name</span> <span class="ow">in</span> <span class="n">g</span><span class="p">:</span>
                <span class="n">parent</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="n">parent_name</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">parent</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="n">UVertex</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="n">parent_name</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">reverse</span><span class="p">:</span>
                <span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">vertex</span><span class="p">,</span> <span class="n">parent</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">vertex</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">g</span></div>


<div class="viewcode-block" id="PGraph.Adjacency">
<a class="viewcode-back" href="../PGraph.html#PGraph.PGraph.Adjacency">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">Adjacency</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create graph from adjacency matrix</span>

<span class="sd">        :param A: adjacency matrix</span>
<span class="sd">        :type A: ndarray(N,N)</span>
<span class="sd">        :param coords: coordinates of vertices, defaults to None</span>
<span class="sd">        :type coords: ndarray(N,M), optional</span>
<span class="sd">        :param names: names of vertices, defaults to None</span>
<span class="sd">        :type names: list(N) of str, optional</span>

<span class="sd">        :return: [description]</span>
<span class="sd">        :rtype: [type]</span>

<span class="sd">        Create a directed or undirected graph where non-zero elements ``A[i,j]``</span>
<span class="sd">        correspond to edges from vertex ``i`` to vertex ``j``.</span>

<span class="sd">        .. warning:: For undirected graph ``A`` should be symmetric but this</span>
<span class="sd">            is not checked.  Only the upper triangular part is used.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Adjacency matrix must be square&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="o">!=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;length of names must match dimension of adjacency matrix&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;coords must have same number of rows as adjacency matrix&quot;</span><span class="p">)</span>

        <span class="n">g</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">()</span>

        <span class="n">name</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">coord</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">coord</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">g</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">coord</span><span class="o">=</span><span class="n">coord</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">UGraph</span><span class="p">):</span>
            <span class="c1"># undirected graph</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">g</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">g</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">cost</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># directed graph</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;loops in graph not supported&quot;</span><span class="p">)</span>
                        <span class="n">g</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">g</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">cost</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">g</span></div>


<div class="viewcode-block" id="PGraph.copy">
<a class="viewcode-back" href="../PGraph.html#PGraph.PGraph.copy">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Deepcopy of graph</span>

<span class="sd">        :param g: A graph</span>
<span class="sd">        :type g: PGraph</span>
<span class="sd">        :return: deep copy</span>
<span class="sd">        :rtype: PGraph</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


<div class="viewcode-block" id="PGraph.add_vertex">
<a class="viewcode-back" href="../PGraph.html#PGraph.PGraph.add_vertex">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_vertex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertex</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a vertex to the graph (superclass method)</span>

<span class="sd">        :param vertex: vertex to add</span>
<span class="sd">        :type vertex: Vertex subclass</span>
<span class="sd">        :param name: name of vertex</span>
<span class="sd">        :type name: str</span>

<span class="sd">        ``G.add_vertex(v)`` add vertex ``v`` to the graph ``G``.</span>

<span class="sd">        If the vertex has no name and ``name`` is None give it a default name</span>
<span class="sd">        ``#N`` where ``N`` is a consecutive integer.</span>

<span class="sd">        The vertex is placed into a dictionary with a key equal to its name.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">vertex</span><span class="o">.</span><span class="n">name</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;#</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertexlist</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">vertex</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vertexlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vertex</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vertexdict</span><span class="p">[</span><span class="n">vertex</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">vertex</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;New vertex </span><span class="si">{</span><span class="n">vertex</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">vertex</span><span class="o">.</span><span class="n">coord</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">vertex</span><span class="o">.</span><span class="n">_graph</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_connectivitychange</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">vertex</span></div>


<div class="viewcode-block" id="PGraph.add_edge">
<a class="viewcode-back" href="../PGraph.html#PGraph.PGraph.add_edge">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add an edge to the graph (superclass method)</span>

<span class="sd">        :param v1: first vertex (start if a directed graph)</span>
<span class="sd">        :type v1: Vertex subclass</span>
<span class="sd">        :param v2: second vertex (end if a directed graph)</span>
<span class="sd">        :type v2: Vertex subclass</span>
<span class="sd">        :param kwargs: optional arguments to pass to ``Vertex.connect``</span>
<span class="sd">        :return: edge</span>
<span class="sd">        :rtype: Edge</span>

<span class="sd">        Create an edge between a vertex pair and adds it to the graph.</span>

<span class="sd">        This is a graph centric way of creating an edge.  The</span>
<span class="sd">        alternative is the ``connect`` method of a vertex.</span>

<span class="sd">        :seealso: :meth:`Edge.connect` :meth:`Vertex.connect`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">v1</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">v1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">Vertex</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;v1 must be Vertex subclass or string name&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">v2</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">v2</span><span class="p">]</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="n">Vertex</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;v2 must be Vertex subclass or string name&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;New edge from </span><span class="si">{</span><span class="n">v1</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">v2</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">v1</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="PGraph.remove">
<a class="viewcode-back" href="../PGraph.html#PGraph.PGraph.remove">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove element from graph (superclass method)</span>

<span class="sd">        :param x: element to remove from graph</span>
<span class="sd">        :type x: Edge or Vertex subclass</span>
<span class="sd">        :raises TypeError: unknown type</span>

<span class="sd">        The edge or vertex is removed, and all references and lists are</span>
<span class="sd">        updated.</span>

<span class="sd">        .. warning:: The connectivity of the network may be changed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Edge</span><span class="p">):</span>
            <span class="c1"># remove an edge</span>

            <span class="c1"># remove edge from the edgelist of connected vertices</span>
            <span class="n">x</span><span class="o">.</span><span class="n">v1</span><span class="o">.</span><span class="n">_edgelist</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">x</span><span class="o">.</span><span class="n">v2</span><span class="o">.</span><span class="n">_edgelist</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

            <span class="c1"># indicate that connectivity has changed</span>
            <span class="n">x</span><span class="o">.</span><span class="n">v1</span><span class="o">.</span><span class="n">_connectivitychange</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">x</span><span class="o">.</span><span class="n">v2</span><span class="o">.</span><span class="n">_connectivitychange</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_connectivitychange</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># remove references to the vertices</span>
            <span class="n">x</span><span class="o">.</span><span class="n">v1</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">x</span><span class="o">.</span><span class="n">v2</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># remove from list of all edges</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_edgelist</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Vertex</span><span class="p">):</span>
            <span class="c1"># remove a vertex</span>

            <span class="c1"># remove all edges of this vertex</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">_edgelist</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>

            <span class="c1"># remove from list and dict of all edges</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_vertexlist</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vertexdict</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;expecting Edge or Vertex&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="PGraph.show">
<a class="viewcode-back" href="../PGraph.html#PGraph.PGraph.show">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">show</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;vertices:&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vertexlist</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;edges:&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edgelist</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">n</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Number of vertices</span>

<span class="sd">        :return: Number of vertices</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertexdict</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">ne</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Number of edges</span>

<span class="sd">        :return: Number of vertices</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_edgelist</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">nc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Number of components</span>

<span class="sd">        :return: Number of components</span>
<span class="sd">        :rtype: int</span>

<span class="sd">        .. note::</span>

<span class="sd">            - Components are labeled from 0 to ``g.nc-1``.</span>
<span class="sd">            - A graph coloring algorithm is run if the graph connectivity</span>
<span class="sd">              has changed.</span>

<span class="sd">        .. note:: A lazy approach is used, and if a connectivity changing</span>
<span class="sd">            operation has been performed since the last call, the graph</span>
<span class="sd">            coloring algorithm is run which is potentially expensive for</span>
<span class="sd">            a large graph.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_graphcolor</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ncomponents</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_metricfunc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">metric</span><span class="p">):</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">L1</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">L2</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">SE2</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
            <span class="c1"># wrap angle to range [-pi, pi)</span>
            <span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">metric</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">metric</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">metric</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">metric</span> <span class="o">==</span> <span class="s2">&quot;L1&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">L1</span>
            <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s2">&quot;L2&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">L2</span>
            <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s2">&quot;SE2&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">SE2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;unknown metric&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">metric</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the distance metric for graph</span>

<span class="sd">        :return: distance metric</span>
<span class="sd">        :rtype: callable</span>

<span class="sd">        This is a function of a vector and returns a scalar.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metric</span>

    <span class="nd">@metric</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">metric</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">metric</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the distance metric for graph</span>

<span class="sd">        :param metric: distance metric</span>
<span class="sd">        :type metric: callable or str</span>

<span class="sd">        This is a function of a vector and returns a scalar.  It can be</span>
<span class="sd">        user defined function or a string:</span>

<span class="sd">        - &#39;L1&#39; is the norm :math:`L_1 = \Sigma_i | v_i |`</span>
<span class="sd">        - &#39;L2&#39; is the norm :math:`L_2 = \sqrt{ \Sigma_i v_i^2}`</span>
<span class="sd">        - &#39;SE2&#39; is a mixed norm for vectors :math:`(x, y, \theta)` and</span>
<span class="sd">            is :math:`\sqrt{x^2 + y^2 + \bar{\theta}^2}` where :math:`\bar{\theta}`</span>
<span class="sd">            is :math:`\theta` wrapped to the interval :math:`[-\pi, \pi)`</span>

<span class="sd">        The metric is used by :meth:`closest` and :meth:`distance`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_metric</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metricfunc</span><span class="p">(</span><span class="n">metric</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">heuristic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the heuristic distance metric for graph</span>

<span class="sd">        :return: heuristic distance metric</span>
<span class="sd">        :rtype: callable</span>

<span class="sd">        This is a function of a vector and returns a scalar.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_heuristic</span>

    <span class="nd">@heuristic</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">heuristic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">heuristic</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the heuristic distance metric for graph</span>

<span class="sd">        :param metric: heuristic distance metric</span>
<span class="sd">        :type metric: callable or str</span>

<span class="sd">        This is a function of a vector and returns a scalar.  It can be</span>
<span class="sd">        user defined function or a string:</span>

<span class="sd">        - &#39;L1&#39; is the norm :math:`L_1 = \Sigma_i | v_i |`</span>
<span class="sd">        - &#39;L2&#39; is the norm :math:`L_2 = \sqrt{ \Sigma_i v_i^2}`</span>
<span class="sd">        - &#39;SE2&#39; is a mixed norm for vectors :math:`(x, y, \theta)` and</span>
<span class="sd">            is :math:`\sqrt{x^2 + y^2 + \bar{\theta}^2}` where :math:`\bar{\theta}`</span>
<span class="sd">            is :math:`\theta` wrapped to the interval :math:`[-\pi, \pi)`</span>

<span class="sd">        The heuristic distance is only used by the A* planner :meth:`path_Astar`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_heuristic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metricfunc</span><span class="p">(</span><span class="n">heuristic</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">ss</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">vertex</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> at </span><span class="si">{</span><span class="n">vertex</span><span class="o">.</span><span class="n">coord</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">if</span> <span class="n">vertex</span><span class="o">.</span><span class="n">label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ss</span> <span class="o">+=</span> <span class="s2">&quot; component=</span><span class="si">{vertex.label}</span><span class="s2">&quot;</span>
            <span class="n">s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ss</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get vertex (superclass method)</span>

<span class="sd">        :param i: vertex description</span>
<span class="sd">        :type i: int or str</span>
<span class="sd">        :return: the referenced vertex</span>
<span class="sd">        :rtype: Vertex subclass</span>

<span class="sd">        Retrieve a vertex by index or name:</span>

<span class="sd">        -``g[i]`` is the i&#39;th vertex in the graph.  This reflects the order of</span>
<span class="sd">         addition to the graph.</span>
<span class="sd">        -``g[s]`` is vertex named ``s``</span>
<span class="sd">        -``g[v]`` is ``v`` where ``v`` is a ``Vertex`` subclass</span>

<span class="sd">        This method also supports iteration over the vertices in a graph::</span>

<span class="sd">            for v in g:</span>
<span class="sd">                print(v)</span>

<span class="sd">        will iterate over all the vertices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vertexlist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vertexdict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">Vertex</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">i</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test if vertex in graph</span>

<span class="sd">        :param item: vertex or name of vertex</span>
<span class="sd">        :type item: Vertex subclass or str</span>
<span class="sd">        :return: true if vertex exists in the graph</span>
<span class="sd">        :rtype: bool</span>

<span class="sd">        - ``&#39;name&#39; in graph`` is true if a vertex named ``&#39;name&#39;`` exists in the</span>
<span class="sd">          graph.</span>
<span class="sd">        - ``v in graph`` is true if the vertex reference ``v`` exists in the</span>
<span class="sd">          graph.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vertexdict</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">Vertex</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vertexdict</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

<div class="viewcode-block" id="PGraph.closest">
<a class="viewcode-back" href="../PGraph.html#PGraph.PGraph.closest">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">closest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coord</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Vertex closest to point</span>

<span class="sd">        :param coord: coordinates of a point</span>
<span class="sd">        :type coord: ndarray(n)</span>
<span class="sd">        :return: closest vertex</span>
<span class="sd">        :rtype: Vertex subclass</span>

<span class="sd">        Returns the vertex closest to the given point. Distance is computed</span>
<span class="sd">        according to the graph&#39;s metric.</span>

<span class="sd">        :seealso: :meth:`metric`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">min_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">min_which</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metric</span><span class="p">(</span><span class="n">vertex</span><span class="o">.</span><span class="n">coord</span> <span class="o">-</span> <span class="n">coord</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="n">min_dist</span><span class="p">:</span>
                <span class="n">min_dist</span> <span class="o">=</span> <span class="n">d</span>
                <span class="n">min_which</span> <span class="o">=</span> <span class="n">vertex</span>

        <span class="k">return</span> <span class="n">min_which</span><span class="p">,</span> <span class="n">min_dist</span></div>


<div class="viewcode-block" id="PGraph.edges">
<a class="viewcode-back" href="../PGraph.html#PGraph.PGraph.edges">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get all edges in graph (superclass method)</span>

<span class="sd">        :return: All edges in the graph</span>
<span class="sd">        :rtype: list of Edge references</span>

<span class="sd">        We can iterate over all edges in the graph by::</span>

<span class="sd">            for e in g.edges():</span>
<span class="sd">                print(e)</span>

<span class="sd">        .. note:: The ``edges()`` of a Vertex is a list of all edges connected</span>
<span class="sd">            to that vertex.</span>

<span class="sd">        :seealso: :meth:`Vertex.edges`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edgelist</span></div>


<div class="viewcode-block" id="PGraph.plot">
<a class="viewcode-back" href="../PGraph.html#PGraph.PGraph.plot">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">colorcomponents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">force2d</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">vopt</span><span class="o">=</span><span class="p">{},</span>
        <span class="n">eopt</span><span class="o">=</span><span class="p">{},</span>
        <span class="n">text</span><span class="o">=</span><span class="p">{},</span>
        <span class="n">block</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">grid</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the graph</span>

<span class="sd">        :param vopt: vertex format, defaults to 12pt o-marker</span>
<span class="sd">        :type vopt: dict, optional</span>
<span class="sd">        :param eopt: edge format, defaults to None</span>
<span class="sd">        :type eopt: dict, optional</span>
<span class="sd">        :param text: text label format, defaults to None</span>
<span class="sd">        :type text: False or dict, optional</span>
<span class="sd">        :param colorcomponents: color vertices and edges by component, defaults to None</span>
<span class="sd">        :type color: bool, optional</span>
<span class="sd">        :param block: block until figure is dismissed, defaults to True</span>
<span class="sd">        :type block: bool, optional</span>

<span class="sd">        The graph is plotted using matplotlib.</span>

<span class="sd">        If ``colorcomponents`` is True then each component is assigned a unique</span>
<span class="sd">        color.  ``vertex`` and ``edge`` cannot include a color keyword.</span>

<span class="sd">        If ``text`` is a dict it is used to format text labels for the vertices</span>
<span class="sd">        which are the vertex names.  If ``text`` is None default formatting is</span>
<span class="sd">        used.  If ``text`` is False no labels are added.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vopt</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="nb">dict</span><span class="p">(</span><span class="n">marker</span><span class="o">=</span><span class="s2">&quot;o&quot;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">12</span><span class="p">),</span> <span class="o">**</span><span class="n">vopt</span><span class="p">}</span>
        <span class="n">eopt</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="nb">dict</span><span class="p">(</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">),</span> <span class="o">**</span><span class="n">eopt</span><span class="p">}</span>

        <span class="k">if</span> <span class="n">colorcomponents</span><span class="p">:</span>
            <span class="n">color</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">coolwarm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nc</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">coord</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">force2d</span><span class="p">:</span>
            <span class="c1"># 2D plotting</span>
            <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ax</span> <span class="o">=</span> <span class="n">axes_logic</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nc</span><span class="p">):</span>
                <span class="c1"># for each component</span>
                <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">component</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">text</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
                        <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">vertex</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">vertex</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="s2">&quot;  &quot;</span> <span class="o">+</span> <span class="n">vertex</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">text</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">colorcomponents</span><span class="p">:</span>
                        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">vertex</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">vertex</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">[</span><span class="n">c</span><span class="p">,</span> <span class="p">:],</span> <span class="o">**</span><span class="n">vopt</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vertex</span><span class="o">.</span><span class="n">neighbours</span><span class="p">():</span>
                            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                                <span class="p">[</span><span class="n">vertex</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">x</span><span class="p">],</span>
                                <span class="p">[</span><span class="n">vertex</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">y</span><span class="p">],</span>
                                <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">[</span><span class="n">c</span><span class="p">,</span> <span class="p">:],</span>
                                <span class="o">**</span><span class="n">eopt</span><span class="p">,</span>
                            <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">vertex</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">vertex</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">vopt</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vertex</span><span class="o">.</span><span class="n">neighbours</span><span class="p">():</span>
                            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">vertex</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">x</span><span class="p">],</span> <span class="p">[</span><span class="n">vertex</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">y</span><span class="p">],</span> <span class="o">**</span><span class="n">eopt</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># 3D or higher plotting, just do (x, y, z)</span>
            <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ax</span> <span class="o">=</span> <span class="n">axes_logic</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nc</span><span class="p">):</span>
                <span class="c1"># for each component</span>
                <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">component</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">text</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
                        <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span>
                            <span class="n">vertex</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">vertex</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">vertex</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="s2">&quot;  &quot;</span> <span class="o">+</span> <span class="n">vertex</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">text</span>
                        <span class="p">)</span>
                    <span class="k">if</span> <span class="n">colorcomponents</span><span class="p">:</span>
                        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                            <span class="n">vertex</span><span class="o">.</span><span class="n">x</span><span class="p">,</span>
                            <span class="n">vertex</span><span class="o">.</span><span class="n">y</span><span class="p">,</span>
                            <span class="n">vertex</span><span class="o">.</span><span class="n">z</span><span class="p">,</span>
                            <span class="o">**</span><span class="p">{</span><span class="o">**</span><span class="nb">dict</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">[</span><span class="n">c</span><span class="p">,</span> <span class="p">:]),</span> <span class="o">**</span><span class="n">vopt</span><span class="p">},</span>
                        <span class="p">)</span>
                        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vertex</span><span class="o">.</span><span class="n">neighbours</span><span class="p">():</span>
                            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                                <span class="p">[</span><span class="n">vertex</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">x</span><span class="p">],</span>
                                <span class="p">[</span><span class="n">vertex</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">y</span><span class="p">],</span>
                                <span class="p">[</span><span class="n">vertex</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">],</span>
                                <span class="o">**</span><span class="p">{</span><span class="o">**</span><span class="nb">dict</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">[</span><span class="n">c</span><span class="p">,</span> <span class="p">:]),</span> <span class="o">**</span><span class="n">eopt</span><span class="p">},</span>
                            <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">vertex</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">vertex</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">vopt</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vertex</span><span class="o">.</span><span class="n">neighbours</span><span class="p">():</span>
                            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                                <span class="p">[</span><span class="n">vertex</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">x</span><span class="p">],</span>
                                <span class="p">[</span><span class="n">vertex</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">y</span><span class="p">],</span>
                                <span class="p">[</span><span class="n">vertex</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">],</span>
                                <span class="o">**</span><span class="n">eopt</span><span class="p">,</span>
                            <span class="p">)</span>
        <span class="c1"># if nc &gt; 1:</span>
        <span class="c1">#     # add a colorbar</span>
        <span class="c1">#     plt.colorbar()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">)</span></div>


<div class="viewcode-block" id="PGraph.highlight_path">
<a class="viewcode-back" href="../PGraph.html#PGraph.PGraph.highlight_path">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">highlight_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Highlight a path through the graph</span>

<span class="sd">        :param path: [description]</span>
<span class="sd">        :type path: [type]</span>
<span class="sd">        :param block: [description], defaults to True</span>
<span class="sd">        :type block: bool, optional</span>

<span class="sd">        The vertices and edges along the path are overwritten with a different</span>
<span class="sd">        size/width and color.</span>

<span class="sd">        :seealso: :meth:`highlight_vertex` :meth:`highlight_edge`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">e</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">edgeto</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">highlight_edge</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">highlight_vertex</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">)</span></div>


<div class="viewcode-block" id="PGraph.highlight_edge">
<a class="viewcode-back" href="../PGraph.html#PGraph.PGraph.highlight_edge">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">highlight_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Highlight an edge in the graph</span>

<span class="sd">        :param edge: The edge to highlight</span>
<span class="sd">        :type edge: Edge subclass</span>
<span class="sd">        :param scale: Overwrite with a line this much bigger than the original,</span>
<span class="sd">                      defaults to 1.5</span>
<span class="sd">        :type scale: float, optional</span>
<span class="sd">        :param color: Overwrite with a line in this color, defaults to &#39;r&#39;</span>
<span class="sd">        :type color: str, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">v1</span>
        <span class="n">p2</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">v2</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="p">[</span><span class="n">p1</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">p2</span><span class="o">.</span><span class="n">x</span><span class="p">],</span> <span class="p">[</span><span class="n">p1</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">p2</span><span class="o">.</span><span class="n">y</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span> <span class="o">*</span> <span class="n">scale</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="PGraph.highlight_vertex">
<a class="viewcode-back" href="../PGraph.html#PGraph.PGraph.highlight_vertex">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">highlight_vertex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertex</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Highlight a vertex in the graph</span>

<span class="sd">        :param edge: The vertex to highlight</span>
<span class="sd">        :type edge: Vertex subclass</span>
<span class="sd">        :param scale: Overwrite with a line this much bigger than the original,</span>
<span class="sd">                      defaults to 1.5</span>
<span class="sd">        :type scale: float, optional</span>
<span class="sd">        :param color: Overwrite with a line in this color, defaults to &#39;r&#39;</span>
<span class="sd">        :type color: str, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vertex</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">vertex</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="s2">&quot;o&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">12</span> <span class="o">*</span> <span class="n">scale</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                <span class="n">vertex</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">vertex</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="s2">&quot;o&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">12</span> <span class="o">*</span> <span class="n">scale</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="PGraph.dotfile">
<a class="viewcode-back" href="../PGraph.html#PGraph.PGraph.dotfile">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">dotfile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Export graph as a GraphViz dot file</span>

<span class="sd">        :param filename: filename to save graph to, defaults to None</span>
<span class="sd">        :type filename: str, optional</span>

<span class="sd">        ``g.dotfile()`` creates the specified file which contains the</span>
<span class="sd">        `GraphViz &lt;https://graphviz.org&gt;`_ code to represent the embedded graph.  By default output</span>
<span class="sd">        is to the console.</span>

<span class="sd">        .. note::</span>

<span class="sd">            - The graph is undirected if it is a subclass of ``UGraph``</span>
<span class="sd">            - The graph is directed if it is a subclass of ``DGraph``</span>
<span class="sd">            - Use ``neato`` rather than dot to get the embedded layout</span>

<span class="sd">        .. note:: If ``filename`` is a file object then the file will *not*</span>
<span class="sd">            be closed after the GraphViz model is written.</span>

<span class="sd">        :seealso: :func:`showgraph`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">filename</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">DGraph</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;digraph {&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;graph {&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">direction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;rankdir = </span><span class="si">{</span><span class="n">direction</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>

        <span class="c1"># add the vertices including name and position</span>
        <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">vertex</span><span class="o">.</span><span class="n">coord</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  &quot;</span><span class="si">{:s}</span><span class="s1">&quot;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">vertex</span><span class="o">.</span><span class="n">name</span><span class="p">),</span> <span class="n">file</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s1">&#39;  &quot;</span><span class="si">{:s}</span><span class="s1">&quot; [pos=&quot;</span><span class="si">{:.5g}</span><span class="s1">,</span><span class="si">{:.5g}</span><span class="s1">&quot;]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">vertex</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">vertex</span><span class="o">.</span><span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">vertex</span><span class="o">.</span><span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="p">),</span>
                    <span class="n">file</span><span class="o">=</span><span class="n">f</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">file</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
        <span class="c1"># add the edges</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">DGraph</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  &quot;</span><span class="si">{:s}</span><span class="s1">&quot; -&gt; &quot;</span><span class="si">{:s}</span><span class="s1">&quot;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">v1</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">v2</span><span class="o">.</span><span class="n">name</span><span class="p">),</span> <span class="n">file</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  &quot;</span><span class="si">{:s}</span><span class="s1">&quot; -- &quot;</span><span class="si">{:s}</span><span class="s1">&quot;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">v1</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">v2</span><span class="o">.</span><span class="n">name</span><span class="p">),</span> <span class="n">file</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;}&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>  <span class="c1"># noqa</span></div>


<div class="viewcode-block" id="PGraph.showgraph">
<a class="viewcode-back" href="../PGraph.html#PGraph.PGraph.showgraph">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">showgraph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Display graph in a browser tab</span>

<span class="sd">        :param kwargs: arguments passed to :meth:`dotfile`</span>

<span class="sd">        ``g.showgraph()`` renders and displays the graph in a browser tab.  The</span>
<span class="sd">        graph is exported in `GraphViz &lt;https://graphviz.org&gt;`_ format, rendered to</span>
<span class="sd">        PDF using ``dot`` and then displayed in a browser tab.</span>

<span class="sd">        :seealso: :func:`dotfile`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># create the temporary dotfile</span>
        <span class="n">dotfile</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">TemporaryFile</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;w&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dotfile</span><span class="p">(</span><span class="n">dotfile</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># rewind the dot file, create PDF file in the filesystem, run dot</span>
        <span class="n">dotfile</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">pdffile</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">NamedTemporaryFile</span><span class="p">(</span><span class="n">suffix</span><span class="o">=</span><span class="s2">&quot;.pdf&quot;</span><span class="p">,</span> <span class="n">delete</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="s2">&quot;dot -Tpdf&quot;</span><span class="p">,</span> <span class="n">shell</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">stdin</span><span class="o">=</span><span class="n">dotfile</span><span class="p">,</span> <span class="n">stdout</span><span class="o">=</span><span class="n">pdffile</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">returncode</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># dot ran happily</span>
            <span class="c1"># open the PDF file in browser (hopefully portable), then cleanup</span>
            <span class="n">webbrowser</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;file://</span><span class="si">{</span><span class="n">pdffile</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>

            <span class="c1"># time.sleep(1)</span>
            <span class="c1"># os.remove(pdffile.name)</span>

<div class="viewcode-block" id="PGraph.iscyclic">
<a class="viewcode-back" href="../PGraph.html#PGraph.PGraph.iscyclic">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">iscyclic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span></div>


<div class="viewcode-block" id="PGraph.average_degree">
<a class="viewcode-back" href="../PGraph.html#PGraph.PGraph.average_degree">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">average_degree</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Average degree of the graph</span>

<span class="sd">        :return: average degree</span>
<span class="sd">        :rtype: float</span>

<span class="sd">        Average degree is :math:`2 E / N` for an undirected graph and</span>
<span class="sd">        :math:`E / N` for a directed graph where :math:`E` is the total number of</span>
<span class="sd">        edges and :math:`N` is the number of vertices.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">DGraph</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">UGraph</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span></div>


    <span class="c1"># --------------------------------------------------------------------------- #</span>

    <span class="c1"># MATRIX REPRESENTATIONS</span>

<div class="viewcode-block" id="PGraph.Laplacian">
<a class="viewcode-back" href="../matrices.html#PGraph.PGraph.Laplacian">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">Laplacian</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Laplacian matrix for the graph</span>

<span class="sd">        :return: Laplacian matrix</span>
<span class="sd">        :rtype: NumPy ndarray</span>

<span class="sd">        ``g.Laplacian()`` is the Laplacian matrix (NxN) of the graph where N</span>
<span class="sd">        is the number of vertices.</span>

<span class="sd">        .. note::</span>

<span class="sd">            - Laplacian is always positive-semidefinite.</span>
<span class="sd">            - Laplacian has at least one zero eigenvalue.</span>
<span class="sd">            - The number of zero-valued eigenvalues is the number of connected</span>
<span class="sd">                components in the graph.</span>

<span class="sd">        :seealso: :meth:`adjacency` :meth:`incidence` :meth:`degree`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">adjacency</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span></div>


<div class="viewcode-block" id="PGraph.connectivity">
<a class="viewcode-back" href="../PGraph.html#PGraph.PGraph.connectivity">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">connectivity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertices</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Graph connectivity</span>

<span class="sd">        :return: a list with the number of edges per vertex</span>
<span class="sd">        :rtype: list</span>

<span class="sd">        The average vertex connectivity is::</span>

<span class="sd">            mean(g.connectivity())</span>

<span class="sd">        and the minimum vertex connectivity is::</span>

<span class="sd">            min(g.connectivity())</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">c</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">vertices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">vertices</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">vertices</span><span class="p">:</span>
            <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">_edgelist</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">c</span></div>


<div class="viewcode-block" id="PGraph.degree">
<a class="viewcode-back" href="../matrices.html#PGraph.PGraph.degree">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">degree</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Degree matrix of graph</span>

<span class="sd">        :return: degree matrix</span>
<span class="sd">        :rtype: ndarray(N,N)</span>

<span class="sd">        This is a diagonal matrix  where element ``[i,i]`` is the number</span>
<span class="sd">        of edges connected to vertex id ``i``.</span>

<span class="sd">        :seealso: :meth:`adjacency` :meth:`incidence` :meth:`laplacian`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">connectivity</span><span class="p">())</span></div>


<div class="viewcode-block" id="PGraph.adjacency">
<a class="viewcode-back" href="../matrices.html#PGraph.PGraph.adjacency">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">adjacency</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adjacency matrix of graph</span>

<span class="sd">        :returns: adjacency matrix</span>
<span class="sd">        :rtype: ndarray(N,N)</span>

<span class="sd">        The elements of the adjacency matrix ``[i,j]`` are 1 if vertex ``i`` is</span>
<span class="sd">        connected to vertex ``j``, else 0.</span>

<span class="sd">        .. note::</span>

<span class="sd">            - vertices are numbered in their order of creation. A vertex index</span>
<span class="sd">              can be resolved to a vertex reference by ``graph[i]``.</span>
<span class="sd">            - for an undirected graph the matrix is symmetric</span>
<span class="sd">            - Eigenvalues of ``A`` are real and are known as the spectrum of the graph.</span>
<span class="sd">            - The element ``A[i,j]`` can be considered the number of walks of length one</span>
<span class="sd">              edge from vertex ``i`` to vertex ``j`` (either zero or one).</span>
<span class="sd">            - If ``Ak = A ** k`` the element ``Ak[i,j]`` is the number of</span>
<span class="sd">              walks of length ``k`` from vertex ``i`` to vertex ``j``.</span>

<span class="sd">        :seealso: :meth:`Laplacian` :meth:`incidence` :meth:`degree`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># create a dict mapping vertex to an id</span>
        <span class="n">vdict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">vert</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">vdict</span><span class="p">[</span><span class="n">vert</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>

        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">vertex</span><span class="o">.</span><span class="n">neighbours</span><span class="p">():</span>
                <span class="n">A</span><span class="p">[</span><span class="n">vdict</span><span class="p">[</span><span class="n">vertex</span><span class="p">],</span> <span class="n">vdict</span><span class="p">[</span><span class="n">n</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">A</span></div>


<div class="viewcode-block" id="PGraph.incidence">
<a class="viewcode-back" href="../matrices.html#PGraph.PGraph.incidence">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">incidence</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Incidence matrix of graph</span>

<span class="sd">        :returns: incidence matrix</span>
<span class="sd">        :rtype: ndarray(n,ne)</span>

<span class="sd">        The elements of the incidence matrix ``I[i,j]`` are 1 if vertex ``i`` is</span>
<span class="sd">        connected to edge ``j``, else 0.</span>

<span class="sd">        .. note::</span>

<span class="sd">            - vertices are numbered in their order of creation. A vertex index</span>
<span class="sd">              can be resolved to a vertex reference by ``graph[i]``.</span>
<span class="sd">            - edges are numbered in the order they appear in ``graph.edges()``.</span>

<span class="sd">        :seealso: :meth:`Laplacian` :meth:`adjacency` :meth:`degree`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
        <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)))</span>

        <span class="c1"># create a dict mapping edge to an id</span>
        <span class="n">edict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">edge</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">edges</span><span class="p">):</span>
            <span class="n">edict</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">vertex</span><span class="o">.</span><span class="n">edges</span><span class="p">()):</span>
                <span class="n">I</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">edict</span><span class="p">[</span><span class="n">e</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">I</span></div>


<div class="viewcode-block" id="PGraph.distance">
<a class="viewcode-back" href="../matrices.html#PGraph.PGraph.distance">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">distance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Distance matrix of graph</span>

<span class="sd">        :return: distance matrix</span>
<span class="sd">        :rtype: ndarray(n,n)</span>

<span class="sd">        The elements of the distance matrix ``D[i,j]`` is the edge cost of moving</span>
<span class="sd">        from vertex ``i`` to vertex ``j``. It is zero if the vertices are not</span>
<span class="sd">        connected.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># create a dict mapping vertex to an id</span>
        <span class="n">vdict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">vert</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">vdict</span><span class="p">[</span><span class="n">vert</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>

        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">v1</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">v2</span><span class="p">,</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">v1</span><span class="o">.</span><span class="n">incidences</span><span class="p">():</span>
                <span class="n">A</span><span class="p">[</span><span class="n">vdict</span><span class="p">[</span><span class="n">v1</span><span class="p">],</span> <span class="n">vdict</span><span class="p">[</span><span class="n">v2</span><span class="p">]]</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">cost</span>
        <span class="k">return</span> <span class="n">A</span></div>


    <span class="c1"># GRAPH COMPONENTS</span>

<div class="viewcode-block" id="PGraph.component">
<a class="viewcode-back" href="../PGraph.html#PGraph.PGraph.component">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">component</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        All vertices in specified graph component</span>

<span class="sd">        ``graph.component(c)`` is a list of all vertices in graph component ``c``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_graphcolor</span><span class="p">()</span>  <span class="c1"># ensure labels are uptodate</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="n">c</span><span class="p">]</span></div>


<div class="viewcode-block" id="PGraph.samecomponent">
<a class="viewcode-back" href="../PGraph.html#PGraph.PGraph.samecomponent">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">samecomponent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test if vertices belong to same graph component</span>

<span class="sd">        :param v1: vertex</span>
<span class="sd">        :type v1: Vertex subclass</span>
<span class="sd">        :param v2: vertex</span>
<span class="sd">        :type v2: Vertex subclass</span>
<span class="sd">        :return: true if vertices belong to same graph component</span>
<span class="sd">        :rtype: bool</span>

<span class="sd">        Test whether vertices belong to the same component.  For a:</span>

<span class="sd">        - directed graph this implies a path between them</span>
<span class="sd">        - undirected graph there is not necessarily a path between them</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_graphcolor</span><span class="p">()</span>  <span class="c1"># ensure labels are uptodate</span>

        <span class="k">return</span> <span class="n">v1</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="n">v2</span><span class="o">.</span><span class="n">label</span></div>


    <span class="c1"># def remove(self, v):</span>
    <span class="c1">#     # remove edges from neighbour&#39;s edge list</span>
    <span class="c1">#     for e in v.edges():</span>
    <span class="c1">#         next = e.next(v)</span>
    <span class="c1">#         next._edgelist.remove(e)</span>
    <span class="c1">#         next._connectivitychange = True</span>

    <span class="c1">#     # remove references from the graph</span>
    <span class="c1">#     self._vertexlist.remove(v)</span>
    <span class="c1">#     for key, value in self._vertexdict.items():</span>
    <span class="c1">#         if value is v:</span>
    <span class="c1">#             del self._vertexdict[key]</span>
    <span class="c1">#             break</span>

    <span class="c1">#     v._edgelist = []  # remove all references to edges</span>
    <span class="c1"># --------------------------------------------------------------------------- #</span>

<div class="viewcode-block" id="PGraph.path_BFS">
<a class="viewcode-back" href="../planning.html#PGraph.PGraph.path_BFS">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">path_BFS</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">summary</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Breadth-first search for path</span>

<span class="sd">        :param S: start vertex</span>
<span class="sd">        :type S: Vertex subclass</span>
<span class="sd">        :param G: goal vertex</span>
<span class="sd">        :type G: Vertex subclass</span>
<span class="sd">        :return: list of vertices from S to G inclusive, path length</span>
<span class="sd">        :rtype: list of Vertex subclass, float</span>

<span class="sd">        Returns a list of vertices that form a path from vertex ``S`` to</span>
<span class="sd">        vertex ``G`` if possible, otherwise return None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">S</span><span class="p">]</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">Vertex</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;start must be Vertex subclass or string name&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">G</span><span class="p">]</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">Vertex</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;goal must be Vertex subclass or string name&quot;</span><span class="p">)</span>

        <span class="c1"># we use lists not sets since the order is instructive in verbose</span>
        <span class="c1"># mode, really need ordered sets...</span>
        <span class="n">frontier</span> <span class="o">=</span> <span class="p">[</span><span class="n">S</span><span class="p">]</span>
        <span class="n">explored</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">done</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">while</span> <span class="n">frontier</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">()</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;FRONTIER:&quot;</span><span class="p">,</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">v</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">frontier</span><span class="p">]))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;EXPLORED:&quot;</span><span class="p">,</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">v</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">explored</span><span class="p">]))</span>

            <span class="n">x</span> <span class="o">=</span> <span class="n">frontier</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;   expand&quot;</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

            <span class="c1"># expand the vertex</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">neighbours</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="n">G</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;     goal&quot;</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;reached&quot;</span><span class="p">)</span>
                    <span class="n">parent</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
                    <span class="n">done</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>
                <span class="k">if</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">frontier</span> <span class="ow">and</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">explored</span><span class="p">:</span>
                    <span class="c1"># add it to the frontier</span>
                    <span class="n">frontier</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;      add&quot;</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;to the frontier&quot;</span><span class="p">)</span>
                    <span class="n">parent</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
            <span class="k">if</span> <span class="n">done</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">explored</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;     move&quot;</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;to the explored list&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># no path</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># reconstruct the path from start to goal</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">G</span>
        <span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
        <span class="n">length</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">while</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">S</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
            <span class="n">length</span> <span class="o">+=</span> <span class="n">x</span><span class="o">.</span><span class="n">edgeto</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">cost</span>
            <span class="n">path</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">p</span>

        <span class="k">if</span> <span class="n">summary</span> <span class="ow">or</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">explored</span><span class="p">)</span><span class="si">}</span><span class="s2"> vertices explored, </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">frontier</span><span class="p">)</span><span class="si">}</span><span class="s2"> remaining on the frontier&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">path</span><span class="p">,</span> <span class="n">length</span></div>


<div class="viewcode-block" id="PGraph.path_UCS">
<a class="viewcode-back" href="../planning.html#PGraph.PGraph.path_UCS">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">path_UCS</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">summary</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Uniform cost search for path</span>

<span class="sd">        :param S: start vertex</span>
<span class="sd">        :type S: Vertex subclass</span>
<span class="sd">        :param G: goal vertex</span>
<span class="sd">        :type G: Vertex subclass</span>
<span class="sd">        :return: list of vertices from S to G inclusive, path length, tree</span>
<span class="sd">        :rtype: list of Vertex subclass, float, dict</span>

<span class="sd">        Returns a list of vertices that form a path from vertex ``S`` to</span>
<span class="sd">        vertex ``G`` if possible, otherwise return None.</span>

<span class="sd">        The search tree is returned as dict that maps a vertex to its parent.</span>

<span class="sd">        The heuristic is the distance metric of the graph, which defaults to</span>
<span class="sd">        Euclidean distance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">S</span><span class="p">]</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">Vertex</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;start must be Vertex subclass or string name&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">G</span><span class="p">]</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">Vertex</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;goal must be Vertex subclass or string name&quot;</span><span class="p">)</span>

        <span class="n">frontier</span> <span class="o">=</span> <span class="p">[</span><span class="n">S</span><span class="p">]</span>
        <span class="n">explored</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">f</span> <span class="o">=</span> <span class="p">{</span><span class="n">S</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>  <span class="c1"># evaluation function</span>

        <span class="k">while</span> <span class="n">frontier</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">()</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;FRONTIER:&quot;</span><span class="p">,</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="n">f</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="si">:</span><span class="s2">.0f</span><span class="si">}</span><span class="s2">)&quot;</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">frontier</span><span class="p">])</span>
                <span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;EXPLORED:&quot;</span><span class="p">,</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">v</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">explored</span><span class="p">]))</span>

            <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">([</span><span class="n">f</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">frontier</span><span class="p">])</span>  <span class="c1"># minimum f in frontier</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">frontier</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;   expand&quot;</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="n">G</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="c1"># expand the vertex</span>
            <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">incidences</span><span class="p">():</span>
                <span class="n">fnew</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="n">cost</span>
                <span class="k">if</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">frontier</span> <span class="ow">and</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">explored</span><span class="p">:</span>
                    <span class="c1"># add it to the frontier</span>
                    <span class="n">parent</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
                    <span class="n">f</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">fnew</span>
                    <span class="n">frontier</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;      add&quot;</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;to the frontier&quot;</span><span class="p">)</span>

                <span class="k">elif</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">frontier</span><span class="p">:</span>
                    <span class="c1"># neighbour is already in the frontier</span>
                    <span class="c1"># cost of path via x is lower that previous, reparent it</span>
                    <span class="k">if</span> <span class="n">fnew</span> <span class="o">&lt;</span> <span class="n">f</span><span class="p">[</span><span class="n">n</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span>
                                <span class="sa">f</span><span class="s2">&quot; reparent </span><span class="si">{</span><span class="n">n</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">: cost </span><span class="si">{</span><span class="n">fnew</span><span class="si">}</span><span class="s2"> via </span><span class="si">{</span><span class="n">x</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> is less than cost </span><span class="si">{</span><span class="n">f</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="si">}</span><span class="s2"> via </span><span class="si">{</span><span class="n">parent</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">, change parent from </span><span class="si">{</span><span class="n">parent</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">x</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> &quot;</span>
                            <span class="p">)</span>
                        <span class="n">f</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">fnew</span>
                        <span class="n">parent</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>

            <span class="n">explored</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;     move&quot;</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;to the explored list&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># no path</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># reconstruct the path from start to goal</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">G</span>
        <span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
        <span class="n">length</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">while</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">S</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
            <span class="n">length</span> <span class="o">+=</span> <span class="n">p</span><span class="o">.</span><span class="n">edgeto</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">cost</span>
            <span class="n">path</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">p</span>

        <span class="n">parent_names</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parent</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">parent_names</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span>

        <span class="k">if</span> <span class="n">summary</span> <span class="ow">or</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">explored</span><span class="p">)</span><span class="si">}</span><span class="s2"> vertices explored, </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">frontier</span><span class="p">)</span><span class="si">}</span><span class="s2"> remaining on the frontier&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">path</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">parent_names</span></div>


<div class="viewcode-block" id="PGraph.path_Astar">
<a class="viewcode-back" href="../planning.html#PGraph.PGraph.path_Astar">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">path_Astar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">summary</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A* search for path</span>

<span class="sd">        :param S: start vertex</span>
<span class="sd">        :type S: Vertex subclass</span>
<span class="sd">        :param G: goal vertex</span>
<span class="sd">        :type G: Vertex subclass</span>
<span class="sd">        :return: list of vertices from S to G inclusive, path length, tree</span>
<span class="sd">        :rtype: list of Vertex subclass, float, dict</span>

<span class="sd">        Returns a list of vertices that form a path from vertex ``S`` to</span>
<span class="sd">        vertex ``G`` if possible, otherwise return None.</span>

<span class="sd">        The search tree is returned as dict that maps a vertex to its parent.</span>

<span class="sd">        The heuristic is the distance metric of the graph, which defaults to</span>
<span class="sd">        Euclidean distance.</span>

<span class="sd">        :seealso: :meth:`heuristic`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">S</span><span class="p">]</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">Vertex</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;start must be Vertex subclass or string name&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">G</span><span class="p">]</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">Vertex</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;goal must be Vertex subclass or string name&quot;</span><span class="p">)</span>

        <span class="n">frontier</span> <span class="o">=</span> <span class="p">[</span><span class="n">S</span><span class="p">]</span>
        <span class="n">explored</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">g</span> <span class="o">=</span> <span class="p">{</span><span class="n">S</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>  <span class="c1"># cost to come</span>
        <span class="n">f</span> <span class="o">=</span> <span class="p">{</span><span class="n">S</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>  <span class="c1"># evaluation function</span>

        <span class="k">while</span> <span class="n">frontier</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">()</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;FRONTIER:&quot;</span><span class="p">,</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="n">f</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="si">:</span><span class="s2">.0f</span><span class="si">}</span><span class="s2">)&quot;</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">frontier</span><span class="p">])</span>
                <span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;EXPLORED:&quot;</span><span class="p">,</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">v</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">explored</span><span class="p">]))</span>

            <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">([</span><span class="n">f</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">frontier</span><span class="p">])</span>  <span class="c1"># minimum f in frontier</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">frontier</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;   expand&quot;</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="n">G</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="c1"># expand the vertex</span>
            <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">incidences</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">frontier</span> <span class="ow">and</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">explored</span><span class="p">:</span>
                    <span class="c1"># add it to the frontier</span>
                    <span class="n">frontier</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                    <span class="n">parent</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
                    <span class="n">g</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="n">cost</span>  <span class="c1"># update cost to come</span>
                    <span class="n">f</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">n</span><span class="o">.</span><span class="n">heuristic_distance</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>  <span class="c1"># heuristic</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;      add&quot;</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;to the frontier&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">frontier</span><span class="p">:</span>
                    <span class="c1"># neighbour is already in the frontier</span>
                    <span class="n">gnew</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="n">cost</span>
                    <span class="k">if</span> <span class="n">gnew</span> <span class="o">&lt;</span> <span class="n">g</span><span class="p">[</span><span class="n">n</span><span class="p">]:</span>
                        <span class="c1"># cost of path via x is lower that previous, reparent it</span>
                        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span>
                                <span class="sa">f</span><span class="s2">&quot; reparent </span><span class="si">{</span><span class="n">n</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">: cost </span><span class="si">{</span><span class="n">gnew</span><span class="si">}</span><span class="s2"> via </span><span class="si">{</span><span class="n">x</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> is less than cost </span><span class="si">{</span><span class="n">g</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="si">}</span><span class="s2"> via </span><span class="si">{</span><span class="n">parent</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">, change parent from </span><span class="si">{</span><span class="n">parent</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">x</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> &quot;</span>
                            <span class="p">)</span>
                        <span class="n">g</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">gnew</span>
                        <span class="n">f</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">n</span><span class="o">.</span><span class="n">heuristic_distance</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>  <span class="c1"># heuristic</span>

                        <span class="n">parent</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>  <span class="c1"># reparent</span>

            <span class="n">explored</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;     move&quot;</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;to the explored list&quot;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># no path</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># reconstruct the path from start to goal</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">G</span>
        <span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
        <span class="n">length</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">while</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">S</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
            <span class="n">length</span> <span class="o">+=</span> <span class="n">p</span><span class="o">.</span><span class="n">edgeto</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">cost</span>
            <span class="n">path</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">p</span>

        <span class="n">parent_names</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parent</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">parent_names</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span>

        <span class="k">if</span> <span class="n">summary</span> <span class="ow">or</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">explored</span><span class="p">)</span><span class="si">}</span><span class="s2"> vertices explored, </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">frontier</span><span class="p">)</span><span class="si">}</span><span class="s2"> remaining on the frontier&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">path</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">parent_names</span></div>
</div>



<span class="c1"># -------------------------------------------------------------------------- #</span>


<div class="viewcode-block" id="UGraph">
<a class="viewcode-back" href="../ugraph.html#PGraph.UGraph">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">UGraph</span><span class="p">(</span><span class="n">PGraph</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class for undirected graphs</span>

<span class="sd">    .. inheritance-diagram:: UGraph</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="UGraph.add_vertex">
<a class="viewcode-back" href="../ugraph.html#PGraph.UGraph.add_vertex">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_vertex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coord</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add vertex to undirected graph</span>

<span class="sd">        :param coord: coordinate for an embedded graph, defaults to None</span>
<span class="sd">        :type coord: array-like, optional</span>
<span class="sd">        :param name: vertex name, defaults to &quot;#i&quot;</span>
<span class="sd">        :type name: str, optional</span>
<span class="sd">        :return: new vertex</span>
<span class="sd">        :rtype: UVertex</span>

<span class="sd">        - ``g.add_vertex()`` creates a new vertex with optional ``coord`` and</span>
<span class="sd">          ``name``.</span>
<span class="sd">        - ``g.add_vertex(v)`` takes an instance or subclass of UVertex and adds</span>
<span class="sd">          it to the graph</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">UVertex</span><span class="p">):</span>
            <span class="n">vertex</span> <span class="o">=</span> <span class="n">coord</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vertex</span> <span class="o">=</span> <span class="n">UVertex</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="n">vertex</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">vertex</span></div>


<div class="viewcode-block" id="UGraph.vertex_copy">
<a class="viewcode-back" href="../ugraph.html#PGraph.UGraph.vertex_copy">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">vertex_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertex</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">DVertex</span><span class="p">(</span><span class="n">coord</span><span class="o">=</span><span class="n">vertex</span><span class="o">.</span><span class="n">coord</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">vertex</span><span class="o">.</span><span class="n">name</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_graphcolor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Color the graph</span>

<span class="sd">        Performs a depth-first labeling operation, assigning the ``label``</span>
<span class="sd">        attribute of every vertex with a sequential integer starting from 0.</span>

<span class="sd">        This method checks the ``_connectivitychange`` attribute of all vertices</span>
<span class="sd">        and if any are True it will perform the coloring operation. This flag</span>
<span class="sd">        is set True by any operation that adds or removes a vertex or edge.</span>

<span class="sd">        :seealso: :meth:`nc`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connectivitychange</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">([</span><span class="n">n</span><span class="o">.</span><span class="n">_connectivitychange</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]):</span>

            <span class="c1"># color the graph</span>

            <span class="c1"># clear all the labels</span>
            <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="n">vertex</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">vertex</span><span class="o">.</span><span class="n">_connectivitychange</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="n">lastlabel</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
                <span class="n">assignment</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                    <span class="c1"># find first vertex with no label</span>
                    <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="c1"># do BFS</span>
                        <span class="n">q</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="p">]</span>  <span class="c1"># initialize frontier</span>
                        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">v</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>  <span class="c1"># expand v</span>
                            <span class="n">v</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">label</span>
                            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">neighbours</span><span class="p">():</span>
                                <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                                    <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                        <span class="n">lastlabel</span> <span class="o">=</span> <span class="n">label</span>
                        <span class="n">assignment</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">break</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">assignment</span><span class="p">:</span>
                    <span class="k">break</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_ncomponents</span> <span class="o">=</span> <span class="n">lastlabel</span> <span class="o">+</span> <span class="mi">1</span></div>



<div class="viewcode-block" id="DGraph">
<a class="viewcode-back" href="../dgraph.html#PGraph.DGraph">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">DGraph</span><span class="p">(</span><span class="n">PGraph</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class for directed graphs</span>

<span class="sd">    .. inheritance-diagram:: DGraph</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="DGraph.add_vertex">
<a class="viewcode-back" href="../dgraph.html#PGraph.DGraph.add_vertex">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_vertex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coord</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add vertex to directed graph</span>

<span class="sd">        :param coord: coordinate for an embedded graph, defaults to None</span>
<span class="sd">        :type coord: array-like, optional</span>
<span class="sd">        :param name: vertex name, defaults to &quot;#i&quot;</span>
<span class="sd">        :type name: str, optional</span>
<span class="sd">        :return: new vertex</span>
<span class="sd">        :rtype: DVertex</span>

<span class="sd">        - ``g.add_vertex()`` creates a new vertex with optional ``coord`` and</span>
<span class="sd">          ``name``.</span>
<span class="sd">        - ``g.add_vertex(v)`` takes an instance or subclass of DVertex and adds</span>
<span class="sd">          it to the graph</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">Vertex</span><span class="p">):</span>
            <span class="n">vertex</span> <span class="o">=</span> <span class="n">coord</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vertex</span> <span class="o">=</span> <span class="n">DVertex</span><span class="p">(</span><span class="n">coord</span><span class="o">=</span><span class="n">coord</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="n">vertex</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">vertex</span></div>


<div class="viewcode-block" id="DGraph.vertex_copy">
<a class="viewcode-back" href="../dgraph.html#PGraph.DGraph.vertex_copy">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">vertex_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertex</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">DVertex</span><span class="p">(</span><span class="n">coord</span><span class="o">=</span><span class="n">vertex</span><span class="o">.</span><span class="n">coord</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">vertex</span><span class="o">.</span><span class="n">name</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_graphcolor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Color the graph</span>

<span class="sd">        Performs a depth-first labeling operation, assigning the ``label``</span>
<span class="sd">        attribute of every vertex with a sequential integer starting from 0.</span>

<span class="sd">        This method checks the ``_connectivitychange`` attribute of all vertices</span>
<span class="sd">        and if any are True it will perform the coloring operation. This flag</span>
<span class="sd">        is set True by any operation that adds or removes a vertex or edge.</span>

<span class="sd">        :seealso: :meth:`nc`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connectivitychange</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">([</span><span class="n">n</span><span class="o">.</span><span class="n">_connectivitychange</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]):</span>

            <span class="c1"># color the graph</span>

            <span class="c1"># clear all the labels</span>
            <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="n">vertex</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">vertex</span><span class="o">.</span><span class="n">_connectivitychange</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="c1"># initial labeling pass</span>
            <span class="n">merge</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">nextlabel</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># no label, try to inherit one from a neighbour</span>
                    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">neighbours</span><span class="p">():</span>
                        <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="c1"># neighbour has a label</span>
                            <span class="n">v</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">label</span>
                            <span class="k">break</span>

                <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># still not labeled, assign a new label</span>
                    <span class="n">v</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">nextlabel</span>
                    <span class="n">nextlabel</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="c1"># now look for clashes</span>
                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">neighbours</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="c1"># neighbour has no label, give it this one</span>
                        <span class="n">n</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">label</span>
                    <span class="k">elif</span> <span class="n">v</span><span class="o">.</span><span class="n">label</span> <span class="o">!=</span> <span class="n">n</span><span class="o">.</span><span class="n">label</span><span class="p">:</span>
                        <span class="c1"># label clash, note it for merging</span>
                        <span class="n">merge</span><span class="p">[</span><span class="n">n</span><span class="o">.</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">label</span>

            <span class="c1"># merge labels and find unique labels</span>
            <span class="n">unique</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">while</span> <span class="n">v</span><span class="o">.</span><span class="n">label</span> <span class="ow">in</span> <span class="n">merge</span><span class="p">:</span>
                    <span class="n">v</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">merge</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">label</span><span class="p">]</span>
                <span class="n">unique</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>

            <span class="n">final</span> <span class="o">=</span> <span class="p">{</span><span class="n">u</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">unique</span><span class="p">)}</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="n">v</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">final</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">label</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_ncomponents</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique</span><span class="p">)</span></div>



<span class="c1"># ========================================================================== #</span>


<div class="viewcode-block" id="Edge">
<a class="viewcode-back" href="../edge.html#PGraph.Edge">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Edge</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Edge class</span>

<span class="sd">    Is used to represent directed directed and undirected edges.</span>

<span class="sd">    Each edge has:</span>
<span class="sd">    - ``cost`` cost of traversing this edge, required for planning methods</span>
<span class="sd">    - ``data`` reference to arbitrary data associated with the edge</span>
<span class="sd">    - ``v1`` first vertex, start vertex for a directed edge</span>
<span class="sd">    - ``v2`` second vertex, end vertex for a directed edge</span>

<span class="sd">    .. note::</span>

<span class="sd">        - An undirected graph is created by having a single edge object in the</span>
<span class="sd">          edgelist of _each_ vertex.</span>
<span class="sd">        - This class can be inherited to provide user objects with graph capability.</span>
<span class="sd">        - Inheritance is an alternative to providing arbitrary user data.</span>

<span class="sd">    An Edge points to a pair of vertices.  At ``connect`` time the vertices</span>
<span class="sd">    get references back to the Edge object.</span>

<span class="sd">    ``graph.add_edge(v1, v2)`` calls ``v1.connect(v2)``</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Edge.__init__">
<a class="viewcode-back" href="../edge.html#PGraph.Edge.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">v2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cost</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an edge object</span>

<span class="sd">        :param v1: start of the edge, defaults to None</span>
<span class="sd">        :type v1: Vertex subclass, optional</span>
<span class="sd">        :param v2: end of the edge, defaults to None</span>
<span class="sd">        :type v2: Vertex subclass, optional</span>
<span class="sd">        :param cost: edge cost, defaults to None</span>
<span class="sd">        :type cost: any, optional</span>
<span class="sd">        :param data: edge data, defaults to None</span>
<span class="sd">        :type data: any, optional</span>

<span class="sd">        Creates an edge but does not connect it to the vertices or add it to the</span>
<span class="sd">        graph.</span>

<span class="sd">        If vertices are given, and have associated coordinates, the edge cost</span>
<span class="sd">        will be computed according to the distance measure associated with the</span>
<span class="sd">        graph.</span>

<span class="sd">        ``data`` is a way of associating any object with the edge, its value</span>
<span class="sd">        can be found as the ``.data`` attribute of the edge.  An alternative</span>
<span class="sd">        approach is to subclass the ``Edge`` class.</span>

<span class="sd">        .. note:: To compute edge cost from the vertices, the vertices must have</span>
<span class="sd">            been added to the graph.</span>

<span class="sd">        :seealso: :meth:`Edge.connect` :meth:`Vertex.connect`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">v1</span> <span class="o">=</span> <span class="n">v1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">v2</span> <span class="o">=</span> <span class="n">v2</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>

        <span class="c1"># try to compute edge cost as metric distance if not given</span>
        <span class="k">if</span> <span class="n">cost</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cost</span> <span class="o">=</span> <span class="n">cost</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="p">(</span><span class="n">v1</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">v1</span><span class="o">.</span><span class="n">coord</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">v2</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">v2</span><span class="o">.</span><span class="n">coord</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cost</span> <span class="o">=</span> <span class="n">v1</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">metric</span><span class="p">(</span><span class="n">v1</span><span class="o">.</span><span class="n">coord</span> <span class="o">-</span> <span class="n">v2</span><span class="o">.</span><span class="n">coord</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cost</span> <span class="o">=</span> <span class="kc">None</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="n">s</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Edge</span><span class="se">{{</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">v1</span><span class="si">}</span><span class="s2"> -- </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">v2</span><span class="si">}</span><span class="s2">, cost=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">cost</span><span class="si">:</span><span class="s2">.4g</span><span class="se">}}</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot; data=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="n">s</span>

<div class="viewcode-block" id="Edge.connect">
<a class="viewcode-back" href="../edge.html#PGraph.Edge.connect">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">connect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add edge to the graph</span>

<span class="sd">        :param v1: start of the edge</span>
<span class="sd">        :type v1: Vertex subclass</span>
<span class="sd">        :param v2: end of the edge</span>
<span class="sd">        :type v2: Vertex subclass</span>

<span class="sd">        The edge is added to the graph and connects vertices ``v1`` and ``v2``.</span>

<span class="sd">        .. note:: The vertices must already be added to the graph.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">v1</span><span class="o">.</span><span class="n">_graph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;vertex v1 does not belong to a graph&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">v2</span><span class="o">.</span><span class="n">_graph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;vertex v2 does not belong to a graph&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">v1</span><span class="o">.</span><span class="n">_graph</span> <span class="ow">is</span> <span class="n">v2</span><span class="o">.</span><span class="n">_graph</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;vertices must belong to the same graph&quot;</span><span class="p">)</span>

        <span class="c1"># connect edge to its vertices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">v1</span> <span class="o">=</span> <span class="n">v1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">v2</span> <span class="o">=</span> <span class="n">v2</span>

        <span class="c1"># tell the vertices to add edge to their edgelists as appropriate for</span>
        <span class="c1"># DGraph or UGraph</span>
        <span class="n">v1</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="n">edge</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span></div>


<div class="viewcode-block" id="Edge.next">
<a class="viewcode-back" href="../edge.html#PGraph.Edge.next">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">next</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertex</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return other end of an edge</span>

<span class="sd">        :param vertex: one vertex on the edge</span>
<span class="sd">        :type vertex: Vertex subclass</span>
<span class="sd">        :raises ValueError: ``vertex`` is not on the edge</span>
<span class="sd">        :return: the other vertex on the edge</span>
<span class="sd">        :rtype: Vertex subclass</span>

<span class="sd">        ``e.next(v1)`` is the vertex at the other end of edge ``e``, ie. the</span>
<span class="sd">        vertex that is not ``v1``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">v1</span> <span class="ow">is</span> <span class="n">vertex</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">v2</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">v2</span> <span class="ow">is</span> <span class="n">vertex</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">v1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;shouldnt happen&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Edge.vertices">
<a class="viewcode-back" href="../edge.html#PGraph.Edge.vertices">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">DeprecationWarning</span><span class="p">(</span><span class="s2">&quot;use endpoints instead&quot;</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">endpoints</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">v1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">v2</span><span class="p">]</span></div>


    <span class="c1"># def remove(self):</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     Remove edge from graph</span>

    <span class="c1">#     ``e.remove()`` removes ``e`` from the graph, but does not delete the</span>
    <span class="c1">#     edge object.</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     # remove this edge from the edge list of both end vertices</span>
    <span class="c1">#     if self in self.v1._edgelist:</span>
    <span class="c1">#         self.v1._edgelist.remove(self)</span>
    <span class="c1">#     if self in self.v2._edgelist:</span>
    <span class="c1">#         self.v2._edgelist.remove(self)</span>

    <span class="c1">#     # indicate that connectivity has changed</span>
    <span class="c1">#     self.v1._connectivitychange = True</span>
    <span class="c1">#     self.v2._connectivitychange = True</span>

    <span class="c1">#     # remove references to the vertices</span>
    <span class="c1">#     self.v1 = None</span>
    <span class="c1">#     self.v2 = None</span>


<span class="c1"># ========================================================================== #</span>


<div class="viewcode-block" id="Vertex">
<a class="viewcode-back" href="../PGraph.html#PGraph.Vertex">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Vertex</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Superclass for vertices of directed and non-directed graphs.</span>

<span class="sd">    Each vertex has:</span>
<span class="sd">        - ``name``</span>
<span class="sd">        - ``label`` an int indicating which graph component contains it</span>
<span class="sd">        - ``_edgelist`` a list of edge objects that connect this vertex to others</span>
<span class="sd">        - ``coord`` the coordinate in an embedded graph (optional)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coord</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edgelist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">coord</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coord</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">coord</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_connectivitychange</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edgelist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># reference to owning graph</span>
        <span class="c1"># print(&#39;Vertex init&#39;, type(self))</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">:</span><span class="s2">s</span><span class="si">}</span><span class="s2">]&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">coord</span> <span class="o">=</span> <span class="s2">&quot;?&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">coord</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">x</span><span class="si">:</span><span class="s2">.4g</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">])</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">[</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">:</span><span class="s2">s</span><span class="si">}</span><span class="s2">, coord=(</span><span class="si">{</span><span class="n">coord</span><span class="si">}</span><span class="s2">)]&quot;</span>

<div class="viewcode-block" id="Vertex.copy">
<a class="viewcode-back" href="../PGraph.html#PGraph.Vertex.copy">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">cls</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">vertex_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">coord</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span></div>


<div class="viewcode-block" id="Vertex.neighbours">
<a class="viewcode-back" href="../PGraph.html#PGraph.Vertex.neighbours">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">neighbours</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Neighbours of a vertex</span>

<span class="sd">        ``v.neighbours()`` is a list of neighbours of this vertex.</span>

<span class="sd">        .. note:: For a directed graph the neighbours are those on edges leaving this vertex</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">next</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edgelist</span><span class="p">]</span></div>


<div class="viewcode-block" id="Vertex.neighbors">
<a class="viewcode-back" href="../PGraph.html#PGraph.Vertex.neighbors">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">neighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Neighbors of a vertex</span>

<span class="sd">        ``v.neighbors()`` is a list of neighbors of this vertex.</span>

<span class="sd">        .. note:: For a directed graph the neighbours are those on edges leaving this vertex</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">next</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edgelist</span><span class="p">]</span></div>


<div class="viewcode-block" id="Vertex.isneighbour">
<a class="viewcode-back" href="../PGraph.html#PGraph.Vertex.isneighbour">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">isneighbour</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertex</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test if vertex is a neigbour</span>

<span class="sd">        :param vertex: vertex reference</span>
<span class="sd">        :type vertex: Vertex subclass</span>
<span class="sd">        :return: true if a neighbour</span>
<span class="sd">        :rtype: bool</span>

<span class="sd">        For a directed graph this is true only if the edge is from ``self`` to</span>
<span class="sd">        ``vertex``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">next</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edgelist</span><span class="p">]</span></div>


<div class="viewcode-block" id="Vertex.incidences">
<a class="viewcode-back" href="../PGraph.html#PGraph.Vertex.incidences">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">incidences</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Neighbours and edges of a vertex</span>

<span class="sd">        ``v.incidences()`` is a generator that returns a list of incidences,</span>
<span class="sd">        tuples of (vertex, edge) for all neighbours of the vertex ``v``.</span>

<span class="sd">        .. note:: For a directed graph the edges are those leaving this vertex</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[(</span><span class="n">e</span><span class="o">.</span><span class="n">next</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edgelist</span><span class="p">]</span></div>


<div class="viewcode-block" id="Vertex.connect">
<a class="viewcode-back" href="../PGraph.html#PGraph.Vertex.connect">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">connect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">edge</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cost</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Connect two vertices with an edge</span>

<span class="sd">        :param dest: The vertex to connect to</span>
<span class="sd">        :type dest: ``Vertex`` subclass</span>
<span class="sd">        :param edge: Use this as the edge object, otherwise a new ``Edge``</span>
<span class="sd">                     object is created from the vertices being connected,</span>
<span class="sd">                     and the ``cost`` and ``edge`` parameters, defaults to None</span>
<span class="sd">        :type edge: ``Edge`` subclass, optional</span>
<span class="sd">        :param cost: the cost to traverse this edge, defaults to None</span>
<span class="sd">        :type cost: float, optional</span>
<span class="sd">        :param data: reference to arbitrary data associated with the edge,</span>
<span class="sd">                     defaults to None</span>
<span class="sd">        :type data: Any, optional</span>
<span class="sd">        :raises TypeError: vertex types are different subclasses</span>
<span class="sd">        :return: the edge connecting the vertices</span>
<span class="sd">        :rtype: Edge</span>

<span class="sd">        ``v1.connect(v2)`` connects vertex ``v1`` to vertex ``v2``.</span>

<span class="sd">        .. note::</span>

<span class="sd">            - If the vertices subclass ``UVertex`` the edge is undirected, and if</span>
<span class="sd">              they subclass ``DVertex`` the edge is directed.</span>
<span class="sd">            - Vertices must both be of the same ``Vertex`` subclass</span>

<span class="sd">        :seealso: :meth:`Edge`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">dest</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__bases__</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__bases__</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;must connect vertices of same type&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">Edge</span><span class="p">):</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">edge</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">Edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">cost</span><span class="o">=</span><span class="n">cost</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">_edgelist</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">_connectivitychange</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_connectivitychange</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="n">e</span></div>


<div class="viewcode-block" id="Vertex.edgeto">
<a class="viewcode-back" href="../PGraph.html#PGraph.Vertex.edgeto">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">edgeto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dest</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get edge connecting vertex to specific neighbour</span>

<span class="sd">        :param dest: a neigbouring vertex</span>
<span class="sd">        :type dest: ``Vertex`` subclass</span>
<span class="sd">        :raises ValueError: ``dest`` is not a neighbour</span>
<span class="sd">        :return: the edge from this vertex to ``dest``</span>
<span class="sd">        :rtype: Edge</span>

<span class="sd">        .. note::</span>

<span class="sd">            - For a directed graph ``dest`` must be at the arrow end of the edge</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">incidences</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="n">dest</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">e</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;dest is not a neighbour&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Vertex.edges">
<a class="viewcode-back" href="../PGraph.html#PGraph.Vertex.edges">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        All outgoing edges of vertex</span>

<span class="sd">        :return: List of all edges leaving this vertex</span>
<span class="sd">        :rtype: list of Edge</span>

<span class="sd">        .. note::</span>

<span class="sd">            - For a directed graph the edges are those leaving this vertex</span>
<span class="sd">            - For a non-directed graph the edges are those leaving or entering</span>
<span class="sd">                this vertex</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edgelist</span></div>


<div class="viewcode-block" id="Vertex.heuristic_distance">
<a class="viewcode-back" href="../PGraph.html#PGraph.Vertex.heuristic_distance">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">heuristic_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v2</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">heuristic</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span> <span class="o">-</span> <span class="n">v2</span><span class="o">.</span><span class="n">coord</span><span class="p">)</span></div>


<div class="viewcode-block" id="Vertex.distance">
<a class="viewcode-back" href="../PGraph.html#PGraph.Vertex.distance">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coord</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Distance from vertex to point</span>

<span class="sd">        :param coord: coordinates of the point</span>
<span class="sd">        :type coord: ndarray(n) or Vertex</span>
<span class="sd">        :return: distance</span>
<span class="sd">        :rtype: float</span>

<span class="sd">        Distance is computed according to the graph&#39;s metric.</span>

<span class="sd">        :seealso: :meth:`metric`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">Vertex</span><span class="p">):</span>
            <span class="n">coord</span> <span class="o">=</span> <span class="n">coord</span><span class="o">.</span><span class="n">coord</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">metric</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span> <span class="o">-</span> <span class="n">coord</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">degree</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Degree of vertex</span>

<span class="sd">        :return: degree of the vertex</span>
<span class="sd">        :rtype: int</span>

<span class="sd">        Returns the number of edges connected to the vertex.</span>

<span class="sd">        .. note:: For a ``DGraph`` only outgoing edges are considered.</span>

<span class="sd">        :seealso: :meth:`edges`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">x</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The x-coordinate of an embedded vertex</span>

<span class="sd">        :return: The x-coordinate</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">y</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The y-coordinate of an embedded vertex</span>

<span class="sd">        :return: The y-coordinate</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">z</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The z-coordinate of an embedded vertex</span>

<span class="sd">        :return: The z-coordinate</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

<div class="viewcode-block" id="Vertex.closest">
<a class="viewcode-back" href="../PGraph.html#PGraph.Vertex.closest">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">closest</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">closest</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="UVertex">
<a class="viewcode-back" href="../uvertex.html#PGraph.UVertex">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">UVertex</span><span class="p">(</span><span class="n">Vertex</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Vertex subclass for undirected graphs</span>

<span class="sd">    This class can be inherited to provide user objects with graph capability.</span>


<span class="sd">    .. inheritance-diagram:: UVertex</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="UVertex.connect">
<a class="viewcode-back" href="../uvertex.html#PGraph.UVertex.connect">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">connect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Vertex</span><span class="p">):</span>
            <span class="n">e</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Edge</span><span class="p">):</span>
            <span class="n">e</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">edge</span><span class="o">=</span><span class="n">other</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;bad argument&quot;</span><span class="p">)</span>

        <span class="c1"># e = super().connect(other, **kwargs)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_edgelist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
        <span class="n">other</span><span class="o">.</span><span class="n">_edgelist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">_edgelist</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">e</span></div>
</div>



<div class="viewcode-block" id="DVertex">
<a class="viewcode-back" href="../dvertex.html#PGraph.DVertex">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">DVertex</span><span class="p">(</span><span class="n">Vertex</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Vertex subclass for directed graphs</span>

<span class="sd">    This class can be inherited to provide user objects with graph capability.</span>

<span class="sd">    .. inheritance-diagram:: DVertex</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="DVertex.connect">
<a class="viewcode-back" href="../dvertex.html#PGraph.DVertex.connect">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">connect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Vertex</span><span class="p">):</span>
            <span class="n">e</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Edge</span><span class="p">):</span>
            <span class="n">e</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">edge</span><span class="o">=</span><span class="n">other</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;bad argument&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_edgelist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">e</span></div>


<div class="viewcode-block" id="DVertex.remove">
<a class="viewcode-back" href="../dvertex.html#PGraph.DVertex.remove">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edgelist</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># remove all references to edges</span></div>
</div>



<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>

    <span class="n">g</span> <span class="o">=</span> <span class="n">UGraph</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
        <span class="n">g</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">()</span>

    <span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">g</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">g</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="nb">print</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, Peter Corke.
      <span class="lastupdated">Last updated on 08-Jan-2025.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
    <!-- Theme Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-11Q6WJM565"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-11Q6WJM565', {
          'anonymize_ip': false,
      });
    </script> 

</body>
</html>